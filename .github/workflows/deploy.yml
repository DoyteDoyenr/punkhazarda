name: Deploy to GKE

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GKE_CLUSTER: your-cluster-name    # Substitua pelo nome do seu cluster
  GKE_ZONE: us-central1-a           # Substitua pela zona do seu cluster
  DEPLOYMENT_NAME: back-cogna
  IMAGE: back-cogna

jobs:
  setup-build-publish-deploy:
    name: Setup, Build, Publish, and Deploy
    runs-on: ubuntu-latest
    environment: production

    permissions:
      contents: read
      id-token: write

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    # Configuração de autenticação no GCP
    - id: 'auth'
      name: 'Authenticate to Google Cloud'
      uses: 'google-github-actions/auth@v1'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    # Configurar Cloud SDK
    - name: 'Set up Cloud SDK'
      uses: 'google-github-actions/setup-gcloud@v1'

    # Configurar Docker para usar gcloud como credential helper (Artifact Registry)
    - name: 'Configure Docker to use gcloud as a credential helper'
      run: |
        gcloud --quiet auth configure-docker us-central1-docker.pkg.dev

    # Get GKE credentials
    - name: 'Get GKE credentials'
      run: |
        gcloud container clusters get-credentials "$GKE_CLUSTER" --zone "$GKE_ZONE"

    # Build da imagem Docker
    - name: Build Docker image
      run: |
        docker build -t "$IMAGE:$GITHUB_SHA" .
        docker tag "$IMAGE:$GITHUB_SHA" "us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/$IMAGE:$GITHUB_SHA"
        docker tag "$IMAGE:$GITHUB_SHA" "us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/$IMAGE:latest"

    # Push da imagem para Artifact Registry
    - name: Publish Docker image
      run: |
        docker push "us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/$IMAGE:$GITHUB_SHA"
        docker push "us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/$IMAGE:latest"

    # Deploy do PostgreSQL (PVC + Deployment + Service)
    - name: Deploy PostgreSQL PVC
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: postgres-pvc
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
        EOF

    - name: Deploy PostgreSQL
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: postgres
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: postgres
          template:
            metadata:
              labels:
                app: postgres
            spec:
              containers:
                - name: postgres
                  image: bitnami/postgresql:latest
                  ports:
                    - containerPort: 5432
                  env:
                    - name: POSTGRES_USER
                      value: "docker"
                    - name: POSTGRES_PASSWORD
                      value: "docker"
                    - name: POSTGRES_DB
                      value: "main_database"
                  volumeMounts:
                    - mountPath: /bitnami/postgresql
                      name: postgres-data
              volumes:
                - name: postgres-data
                  persistentVolumeClaim:
                    claimName: postgres-pvc
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: postgres
        spec:
          selector:
            app: postgres
          ports:
            - port: 5432
              targetPort: 5432
          type: ClusterIP
        EOF

    # Aguardar PostgreSQL estar pronto
    - name: Wait for PostgreSQL to be ready
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/postgres
        kubectl wait --for=condition=ready --timeout=300s pod -l app=postgres

    # Deploy da aplicação backend
    - name: Deploy Backend Application
      run: |
        cat <<EOF | kubectl apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: back-cogna
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: back-cogna
          template:
            metadata:
              labels:
                app: back-cogna
            spec:
              initContainers:
                - name: wait-for-postgres
                  image: busybox:1.36
                  command:
                    - sh
                    - -c
                    - |
                      until nc -z postgres 5432; do
                        echo "Waiting for postgres...";
                        sleep 2;
                      done;
                      echo "Postgres is up!"
              containers:
                - name: back-cogna
                  image: us-central1-docker.pkg.dev/$PROJECT_ID/my-repo/$IMAGE:$GITHUB_SHA
                  ports:
                    - containerPort: 3333
                  env:
                    - name: NODE_ENV
                      value: "production"
                    - name: PORT
                      value: "3333"
                    - name: JWT_SECRET
                      valueFrom:
                        secretKeyRef:
                          name: app-secrets
                          key: jwt-secret
                    - name: DATABASE_URL
                      value: "postgresql://docker:docker@postgres:5432/main_database"
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: back-cogna
        spec:
          selector:
            app: back-cogna
          ports:
            - port: 3333
              targetPort: 3333
              nodePort: 31333 
          type: NodePort
        EOF

    # Criar secrets do Kubernetes (se não existir)
    - name: Create Kubernetes secrets
      run: |
        kubectl create secret generic app-secrets \
          --from-literal=jwt-secret="${{ secrets.JWT_SECRET }}" \
          --dry-run=client -o yaml | kubectl apply -f -

    # Verificar status do deployment
    - name: Verify deployment
      run: |
        kubectl rollout status deployment/$DEPLOYMENT_NAME
        kubectl get services -o wide